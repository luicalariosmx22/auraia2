"""
Cliente WebSocket para integrar NORA con el backend WhatsApp Web real de Railway
Usa Socket.IO para comunicaci√≥n en tiempo real
"""

import os
import json
import requests
from datetime import datetime
import socketio
import threading
import time

class WhatsAppWebSocketClient:
    """Cliente WebSocket para WhatsApp Web en Railway"""
    
    def __init__(self, backend_url=None):
        # Auto-detectar URL seg√∫n entorno
        if backend_url is None:
            if os.getenv('RAILWAY_ENVIRONMENT'):
                backend_url = 'https://whatsapp-server.railway.internal'
            else:
                backend_url = 'https://whatsapp-server-production-8f61.up.railway.app'
        
        self.backend_url = backend_url.rstrip('/')
        self.is_connected = False
        self.is_authenticated = False
        self.session_active = False
        self.session_id = None
        self.current_qr = None
        
        # Cliente Socket.IO
        self.sio = socketio.Client(
            logger=True,
            engineio_logger=True,
            reconnection=True,
            reconnection_attempts=3,
            reconnection_delay=1
        )
        
        # Configurar event handlers
        self._setup_handlers()
        
        print(f"üîó WhatsApp WebSocket Client: {self.backend_url}")
    
    def _setup_handlers(self):
        """Configurar manejadores de eventos Socket.IO"""
        
        @self.sio.event
        def connect():
            print("‚úÖ Conectado al backend WebSocket")
            self.is_connected = True
        
        @self.sio.event
        def disconnect():
            print("üîå Desconectado del backend WebSocket")
            self.is_connected = False
            self.is_authenticated = False
            self.session_active = False
        
        @self.sio.event
        def connected(data):
            print(f"üì° Sesi√≥n iniciada: {data}")
            self.session_active = True
            # Actualizar session_id si viene
            if isinstance(data, dict) and 'client_id' in data:
                self.session_id = data['client_id']
                print(f"üÜî Session ID actualizado: {self.session_id}")
        
        @self.sio.event
        def qr_code(data):
            print(f"üì± QR recibido: {data.get('message', 'QR generado')}")
            
            # Capturar QR data del backend
            if 'qr_data' in data:
                self.current_qr = data['qr_data']
                print(f"‚úÖ QR actualizado: {type(self.current_qr)} - {len(self.current_qr) if self.current_qr else 0} chars")
                
                # Si es una imagen PNG, confirmar que es v√°lida
                if isinstance(self.current_qr, str) and self.current_qr.startswith('data:image/png;base64,'):
                    print("üì∏ QR es imagen PNG v√°lida del backend")
                elif isinstance(self.current_qr, str) and self.current_qr.startswith('1@'):
                    print("üì± QR es texto plano de WhatsApp Web")
                else:
                    print(f"‚ùì QR en formato inesperado: {self.current_qr[:50] if self.current_qr else 'None'}...")
            
            # Si viene QR como string directo
            if isinstance(data, dict) and 'qr_data' not in data and 'message' in data:
                # Podr√≠a ser que el QR venga en message
                qr_text = data.get('message', '')
                if qr_text and ('1@' in qr_text or 'data:image' in qr_text):
                    self.current_qr = qr_text
                    print(f"‚úÖ QR capturado desde message: {len(qr_text)} chars")
            
            # Actualizar session_id si viene en la respuesta
            if isinstance(data, dict) and 'session_id' in data:
                self.session_id = data['session_id']
                print(f"üÜî Session ID actualizado: {self.session_id}")
            
            # Verificar si hay error espec√≠fico de QR
            if isinstance(data, dict) and 'error' in data:
                print(f"‚ö†Ô∏è Error en QR: {data['error']}")
                # No es un error de conexi√≥n, es un error espec√≠fico de QR
            
            # Verificar mensaje
            if isinstance(data, dict) and 'message' in data:
                print(f"üí¨ Mensaje del backend: {data['message']}")
        
        @self.sio.event
        def authenticated(data):
            print(f"üéâ Autenticado: {data.get('message', '√âxito')}")
            self.is_authenticated = True
            self.session_active = True
        
        @self.sio.event
        def error(data):
            error_msg = data.get('message', 'Error desconocido') if isinstance(data, dict) else str(data)
            print(f"‚ùå Error del backend: {error_msg}")
            
            # Distinguir entre errores de conexi√≥n y errores de aplicaci√≥n
            if 'conexi√≥n' in error_msg.lower() or 'connection' in error_msg.lower():
                print("üîå Error de conexi√≥n detectado")
                self.is_connected = False
            elif 'chrome' in error_msg.lower() or 'browser' in error_msg.lower():
                print("üåê Error de navegador - backend necesita Chrome")
                # No es un error de conexi√≥n, el WebSocket funciona
            else:
                print("‚ö†Ô∏è Error de aplicaci√≥n - conexi√≥n WebSocket OK")
        
        @self.sio.event
        def test_result(data):
            print(f"üß™ Resultado de prueba: {data}")
        
        @self.sio.event
        def heartbeat(data):
            print(f"üíì Heartbeat: {data.get('timestamp', 'Sin timestamp')}")
    
    def get_health_status(self):
        """Obtener estado de salud del backend"""
        try:
            print(f"üè• Health check: {self.backend_url}/health")
            response = requests.get(f"{self.backend_url}/health", timeout=10)
            
            if response.status_code == 200:
                try:
                    data = response.json()
                    print("‚úÖ Backend OK (JSON)")
                    return data
                except:
                    print("‚úÖ Backend OK (HTML)")
                    return {
                        'status': 'ok',
                        'timestamp': datetime.now().isoformat(),
                        'message': 'Backend funcionando'
                    }
            return None
        except Exception as e:
            print(f"‚ùå Error health check: {e}")
            return None
    
    def get_detailed_status(self):
        """Obtener estado detallado"""
        # El backend real no tiene endpoint /status HTTP
        # Devolver estado basado en WebSocket
        return {
            'connected': self.is_connected,
            'authenticated': self.is_authenticated,
            'session_active': self.session_active,
            'session_id': self.session_id,
            'has_qr': self.current_qr is not None,
            'backend_type': 'websocket'
        }
    
    def connect(self):
        """Conectar al backend WebSocket de forma completamente no bloqueante"""
        try:
            if self.is_connected:
                print("‚úÖ Ya conectado")
                return True
            
            print(f"üîó Conectando a WebSocket: {self.backend_url}")
            
            # Conexi√≥n as√≠ncrona sin bloqueo
            try:
                # Usar threading para no bloquear el hilo principal
                def _connect_async():
                    try:
                        self.sio.connect(self.backend_url, transports=['websocket', 'polling'])
                    except Exception as e:
                        print(f"‚ùå Error async conectando: {e}")
                
                # Iniciar conexi√≥n en hilo separado
                connection_thread = threading.Thread(target=_connect_async, daemon=True)
                connection_thread.start()
                
                # Esperar muy poco tiempo para no bloquear
                timeout = 0.5  # Solo 0.5 segundos
                start_time = time.time()
                
                while timeout > 0 and not self.is_connected:
                    time.sleep(0.1)  # Verificar cada 100ms
                    timeout -= 0.1
                    
                    if time.time() - start_time > timeout:
                        break
                
                if self.is_connected:
                    print("‚úÖ Conexi√≥n WebSocket establecida exitosamente")
                    return True
                else:
                    print("‚ö†Ô∏è Conexi√≥n WebSocket en progreso (no bloquear)")
                    return False  # No es un error, solo est√° en progreso
                    
            except Exception as e:
                print(f"‚ùå Error conectando WebSocket: {e}")
                return False
            
        except Exception as e:
            print(f"‚ùå Error general en conexi√≥n: {e}")
            return False
    
    def disconnect(self):
        """Desconectar del backend"""
        try:
            if self.is_connected:
                self.sio.disconnect()
            print("üîå Desconectado")
        except Exception as e:
            print(f"‚ùå Error desconectando: {e}")
    
    def init_session(self):
        """Iniciar sesi√≥n WhatsApp Web (obtener QR) - r√°pido"""
        try:
            if not self.is_connected:
                print("‚ùå No conectado al WebSocket")
                return False
            
            print("üöÄ Solicitando QR de WhatsApp Web...")
            self.sio.emit('get_qr', {
                'session_id': self.session_id,
                'timestamp': datetime.now().isoformat()
            })
            
            # Esperar menos tiempo para la respuesta
            time.sleep(1)  # Reducido de 3s a 1s
            return True
            
        except Exception as e:
            print(f"‚ùå Error iniciando sesi√≥n: {e}")
            return False
    
    def close_session(self):
        """Cerrar sesi√≥n WhatsApp Web"""
        try:
            if not self.is_connected:
                return True
            
            print("üîê Cerrando sesi√≥n WhatsApp Web...")
            self.sio.emit('disconnect_whatsapp', {
                'session_id': self.session_id
            })
            
            self.session_active = False
            self.is_authenticated = False
            self.current_qr = None
            self.session_id = None
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error cerrando sesi√≥n: {e}")
            return False
    
    def check_status(self):
        """Verificar estado de WhatsApp Web"""
        try:
            if not self.is_connected:
                return False
            
            print("üîç Verificando estado...")
            # No hay evento espec√≠fico para esto en el backend
            # Usar estado interno
            return True
            
        except Exception as e:
            print(f"‚ùå Error verificando estado: {e}")
            return False
    
    def get_qr_code(self, force_refresh=False):
        """Obtener c√≥digo QR actual - r√°pido"""
        # Si se solicita refresh o no hay QR, solicitarlo al backend
        if force_refresh or not self.current_qr:
            if self.is_connected:
                print("üì± Solicitando QR fresco al backend...")
                self.sio.emit('get_qr', {
                    'session_id': self.session_id,
                    'timestamp': datetime.now().isoformat(),
                    'force_refresh': force_refresh
                })
                
                # Esperar menos tiempo para la respuesta
                time.sleep(1)  # Reducido de 3s a 1s
        
        return self.current_qr
    
    def send_test_message(self):
        """Enviar mensaje de prueba"""
        try:
            if not self.is_authenticated:
                print("‚ùå WhatsApp no est√° autenticado")
                return False
            
            print("üì§ Enviando mensaje de prueba...")
            self.sio.emit('test_whatsapp', {
                'session_id': self.session_id,
                'action': 'send_test_message',
                'phone_number': '123456789',
                'message': 'Mensaje de prueba desde NORA'
            })
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error enviando mensaje: {e}")
            return False

# Cliente global
_global_client = None

def get_whatsapp_client():
    """Obtener cliente global"""
    global _global_client
    if _global_client is None:
        _global_client = WhatsAppWebSocketClient()
    return _global_client

def test_websocket_client():
    """Probar cliente WebSocket"""
    print("üß™ Test WebSocket WhatsApp Client")
    client = get_whatsapp_client()
    
    # Health check primero
    health = client.get_health_status()
    if not health:
        print("‚ùå Backend no responde")
        return
    
    print(f"‚ù§Ô∏è Backend health: {health.get('status', 'unknown')}")
    
    # Conectar WebSocket
    if client.connect():
        print("‚úÖ WebSocket conectado")
        
        # Solicitar QR
        if client.init_session():
            print("üöÄ Sesi√≥n iniciada")
            
            # Esperar QR
            time.sleep(5)
            
            qr = client.get_qr_code()
            if qr:
                print(f"üì± QR obtenido: {qr[:50]}...")
            else:
                print("‚è≥ QR a√∫n no disponible")
            
            # Status
            status = client.get_detailed_status()
            print(f"üìä Estado: {status}")
        
        # Desconectar
        client.disconnect()
    else:
        print("‚ùå No se pudo conectar WebSocket")

if __name__ == "__main__":
    test_websocket_client()
