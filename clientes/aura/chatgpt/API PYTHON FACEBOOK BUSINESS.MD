Descripci√≥n de proyecto
SDK empresarial de Facebook para Python
PyPI Estado de compilaci√≥n Licencia

Introducci√≥n
El SDK de Facebook para Empresas es una soluci√≥n integral que ayuda a nuestros socios a mejorar el servicio a sus negocios. Los socios utilizan m√∫ltiples API de Facebook para satisfacer las necesidades de sus clientes. Adoptar todas estas API y mantenerlas actualizadas en las distintas plataformas puede ser una tarea laboriosa y, en √∫ltima instancia, prohibitiva. Por ello, Facebook ha desarrollado el SDK para Empresas, integrando muchas de sus API en un solo SDK para facilitar su implementaci√≥n y mantenimiento. El SDK para Empresas es una versi√≥n mejorada del SDK de la API de Marketing, que incluye la API de Marketing, as√≠ como muchas API de Facebook de diferentes plataformas, como P√°ginas, Business Manager, Instagram, etc.

Inicio r√°pido
Gu√≠a de inicio r√°pido del SDK empresarial

Python es actualmente el lenguaje m√°s popular entre nuestros desarrolladores externos. facebook_businessEs un paquete de Python que proporciona una interfaz entre tu aplicaci√≥n Python y las API de Facebook dentro del SDK para empresas . Este tutorial abarca los conocimientos b√°sicos necesarios para usar el SDK y ofrece algunos ejercicios.

NOTA : facebook_business¬°el paquete es compatible con Python 2 y 3!

Prerrequisitos
Registrar una aplicaci√≥n
Para comenzar a utilizar el SDK, debes tener una aplicaci√≥n registrada en developer.facebook.com .

Para administrar la API de marketing, visite el Panel de control de su aplicaci√≥n y agregue el producto API de marketing a su aplicaci√≥n.

IMPORTANTE : Por seguridad, se recomienda que active la opci√≥n 'Prueba de secreto de aplicaci√≥n para llamadas a la API del servidor' en la p√°gina Configuraci√≥n->Avanzada de su aplicaci√≥n.

Obtener un token de acceso
Cuando alguien se conecta con una aplicaci√≥n usando el inicio de sesi√≥n de Facebook y aprueba la solicitud de permisos, la aplicaci√≥n obtiene un token de acceso que proporciona acceso temporal y seguro a las API de Facebook.

Un token de acceso es una cadena opaca que identifica a un usuario, una aplicaci√≥n o una p√°gina.

Por ejemplo, para acceder a la API de marketing, debe generar un token de acceso de usuario para su aplicaci√≥n y solicitar ads_managementpermiso; para acceder a la API de p√°ginas, debe generar un token de acceso de p√°gina para su aplicaci√≥n y solicitar manage_pagepermiso.

Consulte nuestra Gu√≠a de token de acceso para obtener m√°s informaci√≥n.

Por ahora, podemos usar el Explorador de gr√°ficos para obtener un token de acceso.

Instalar paquete
La forma m√°s sencilla de instalar el SDK es a trav√©s pipde su shell.

NOTA : Para Python 3, utilice pip3y python3en su lugar.

NOTA : √öselo sudosi alguno de estos presenta problemas con los permisos. (Esto podr√≠a suceder si est√° usando un sistema con Python instalado).

Si no tienes pip:

easy_install pip
Ahora ejecuta cuando tengas pip:

pip install facebook_business
Si prefieres la √∫ltima versi√≥n en lugar de una versi√≥n posiblemente desactualizada del repositorio pypi.python.org , consulta el repositorio en GitHub o descarga un archivo tar de la versi√≥n . Una vez descargado y descomprimido el paquete, inst√°lalo:

python setup.py install
¬°Genial, ahora est√°s listo para usar el SDK!

Arranque
Crear test.py
Cree un archivo test.py con el contenido a continuaci√≥n (suponiendo que su sistema usa Python 2.7 y est√° instalado en /opt/homebrew. Actualice a la ubicaci√≥n correcta de Python):

import sys sys . path . append ( '/opt/homebrew/lib/python2.7/site-packages' ) # Reemplace esto con el lugar donde instal√≥ facebookads usando pip sys . path . append ( '/opt/homebrew/lib/python2.7/site-packages/facebook_business-3.0.0-py2.7.egg-info' ) # Igual que arriba 
 
 

desde facebook_business.api importar FacebookAdsApi desde facebook_business.adobjects.adaccount importar AdAccount   
   

my_app_id  =  'tu-id-de-aplicaci√≥n' 
my_app_secret  =  'tu-secreto-de-aplicaci√≥n' 
my_access_token  =  'tu-token-de-acceso-a-p√°gina' 
FacebookAdsApi . init ( my_app_id ,  my_app_secret ,  my_access_token ) 
my_account  =  AdAccount ( 'act_<tu-id-de-cuenta-ad>' ) 
campaigns  =  my_account . get_campaigns () 
print ( campaigns )
Pruebe su instalaci√≥n
Pruebe su instalaci√≥n con el siguiente comando:

 prueba de Python .py
Deber√≠a ver el resultado en la ventana de su terminal. Si se informa de un token caducado, repita el proceso para solicitar un token de acceso a la p√°gina descrito en la secci√≥n de prerrequisitos anterior.

NOTA : Usaremos el m√≥dulo de objetos en el resto del tutorial. Tambi√©n puedes usar directamente los archivos de clase individuales en adobjects.

Entendiendo CRUD
El SDK implementa un dise√±o CRUD (crear, leer, actualizar, eliminar). Los objetos relevantes para explorar el gr√°fico se encuentran en el m√≥dulo de objetos del paquete facebook_business.

Todos los objetos del grafo son instancias de AbstractObject. Algunos objetos pueden consultarse directamente y, por lo tanto, son instancias de AbstractCrudObject(una subclase de AbstractObject). Ambas clases abstractas se encuentran en facebook_business.adobjects.

Hay una carpeta adicional adobjectsen facebook_business. All√≠ ver√° un archivo para cada objeto de anuncio en nuestra API de Marketing. Estos archivos se generan autom√°ticamente desde nuestra API y, por lo tanto, son pr√°cticamente iguales a lo que ofrece. Seg√∫n las operaciones CRUD que se puedan realizar en cada objeto, ver√° la presencia de los siguientes m√©todos:

api_get
api_update
api_delete
create_xxx
get_xxx
Por ejemplo, Campaign cuenta con todos estos m√©todos, pero AdAccount no. Consulta la documentaci√≥n de la API de Marketing para obtener m√°s informaci√≥n sobre c√≥mo se utilizan los diferentes objetos de anuncio .

Hay algunas funciones obsoletas en AbstractCrudObject, como

remote_create
remote_read
remote_update
remote_delete
Intente dejar de usarlos ya que es posible que los dejemos obsoletos pronto.

Explorando el gr√°fico
El SDK abstrae la API mediante la definici√≥n de clases que representan objetos en el gr√°fico. Estas definiciones de clase y sus ayudantes se encuentran en facebook_business.adobjects.

Inicializaci√≥n de objetos
Consulte los m√©todos AbstractObjectde y AbstractCrudObjectde __init__para obtener m√°s informaci√≥n. La mayor√≠a de los objetos del gr√°fico pertenecen a una de las dos subclases.

Al instanciar un objeto de anuncio, puedes especificar su ID si ya existe definiendo fbidun argumento. Adem√°s, si quieres interactuar con la API usando un objeto de API espec√≠fico en lugar del predeterminado, puedes especificar el apiargumento.

Bordes
Observa los m√©todos de un objeto para ver qu√© asociaciones podemos iterar. Por ejemplo, un Userobjeto tiene un m√©todo get_ad_accountsque devuelve un iterador de AdAccountobjetos.

Cuenta publicitaria
La mayor√≠a de las operaciones relacionadas con anuncios se realizan en el contexto de una cuenta publicitaria. Puedes ir al Administrador de Anuncios para ver las cuentas para las que tienes permiso. La mayor√≠a de ustedes probablemente tengan una cuenta personal.

Obtengamos todas las cuentas de anuncios del usuario con el token de acceso especificado. Solo tengo una cuenta, as√≠ que se imprime lo siguiente:

>>>  de facebook_business.adobjects.user import Usuario >>> yo = adobjects.User ( fbid = 'yo' ) >>> mis_cuentas = lista ( yo.get_ad_accounts ( )) >>> imprimir ( mis_cuentas ) [ { ' id_cuenta' : u ' 17842443' , ' id' : u ' act_17842443' } ] >>> tipo ( mis_cuentas [ 0 ]) < clase ' facebook_business.adobjects.AdAccount ' >   
   
   
 
      
 
 
ADVERTENCIA : No especificamos un argumento de palabra clave api=apial instanciar el Userobjeto aqu√≠ porque ya hemos configurado la API predeterminada durante el arranque.

NOTA : Envolvemos el valor de retorno de get_ad_accountscon list() porque get_ad_accountsdevuelve un EdgeIteratorobjeto (ubicado en facebook_business.adobjects) y queremos obtener la lista completa de inmediato en lugar de que el iterador cargue las cuentas de manera diferida.

Para nuestros prop√≥sitos, podemos simplemente elegir una cuenta y hacer nuestros experimentos en su contexto:

>>>  mi_cuenta  =  mis_cuentas [ 0 ]
O si ya conoces el ID de tu cuenta:

>>>  mi_cuenta  =  adobjects . CuentaAd ( 'act_17842443' )
Crear
Creemos una campa√±a. Est√° en el contexto de la cuenta, es decir, su padre deber√≠a ser la cuenta.

campos  =  [ 
] 
par√°metros  =  { 
  adobjects . Campaign . Field . name  :  'Conversiones de la campa√±a' , 
  adobjects . Campaign . Field . configuration_status :  adobjects . Campaign . Status . paused , 
} 
campa√±a  =  AdAccount ( id ) . create_campaign ( campos ,  par√°metros )
A continuaci√≥n, especificamos algunos detalles sobre la campa√±a. Para determinar qu√© propiedades definir, consulte los campos disponibles del objeto (ubicados en [nombre del objeto Campaign.Field]) y tambi√©n la documentaci√≥n del objeto de anuncio (por ejemplo, " Campa√±a ").

NOTA : Para encontrar los campos, mire el archivo de clase individual en el directorio adobjects.

Si se produce un error, se generar√° una excepci√≥n. Las posibles excepciones y sus descripciones se enumeran en facebook_business.exceptions.

Leer
Tambi√©n podemos leer las propiedades de un objeto desde la API, suponiendo que el objeto ya est√° creado y tiene una ruta de nodo. Acceder a las propiedades de un objeto es sencillo, ya que AbstractObjectimplementa collections.MutableMapping. Se puede acceder a ellas como si se accediera a la clave de un diccionario:

>>>  print ( mi_cuenta ) 
{ 'id_cuenta' :  u '17842443' ,  'id' :  u 'act_17842443' } 
>>>  mi_cuenta  =  mi_cuenta . api_get ( campos = [ adobjects . AdAccount . Field . amount_spent ]) 
>>>  print ( mi_cuenta [ adobjects . AdAccount . Field . amount_spent ]) 
{ 'amount_spent' :  21167 ,  'id_cuenta' :  u '17842443' ,  'id' :  u 'act_17842443' }
Actualizar
Para actualizar un objeto, podemos modificar sus propiedades y luego llamar al api_updatem√©todo para sincronizarlo con el servidor. Corrijamos la errata de "Campa√±a" por "Campa√±a":

>>>  campa√±a.api_update ( campos = [ ] , par√°metros = { adobjects.campa√±a.campo.nombre : " Campa√±a de la Papa " } ) 
Puedes ver los resultados en el administrador de anuncios.

Borrar
Si decidimos que ya no queremos la campa√±a que creamos:

campa√±a .api_delete ( )
Argumentos √∫tiles
TOKENS DE ACCESO M√öLTIPLE
En la documentaci√≥n, se llama al m√©todo FacebookAdsApi.init antes de realizar cualquier llamada a la API. Este m√©todo configura un objeto FacebookAdsApi predeterminado que se usa en todas partes. Esto simplifica el uso, pero no es viable cuando un sistema que usa el SDK realiza llamadas en nombre de varios usuarios.

Esto no es viable porque cada usuario deber√≠a tener su propia sesi√≥n de Facebook, con su propio token de acceso, en lugar de usar la misma sesi√≥n para todos. Cada sesi√≥n deber√≠a usarse para crear un objeto FacebookAdsApi independiente. Vea el ejemplo a continuaci√≥n:

my_app_id  =  '<APP_ID>' 
my_app_secret  =  '<APP_SECRET>' 
my_access_token_1  =  '<ACCESS_TOKEN_1>' 
my_access_token_2  =  '<ACCESS_TOKEN_2>' 
proxies  =  { 'http' :  '<HTTP_PROXY>' ,  'https' :  '<HTTPS_PROXY>' }  # agregue proxies si es necesario

sesi√≥n1  =  FacebookSession ( 
    mi_id_de_aplicaci√≥n , 
    mi_secreto_de_aplicaci√≥n , 
    mi_token_de_acceso_1 , 
    proxies , 
)

sesi√≥n2  =  FacebookSession ( 
    mi_id_de_aplicaci√≥n , 
    mi_secreto_de_aplicaci√≥n , 
    mi_token_de_acceso_2 , 
    proxies , 
)

api1  =  FacebookAdsApi ( sesi√≥n1 ) 
api2  =  FacebookAdsApi ( sesi√≥n2 )
En los ejemplos del SDK, siempre configuramos un √∫nico objeto FacebookAdsApi como predeterminado. Sin embargo, al trabajar con varios tokens de acceso, es necesario usar varias API. Podemos configurar una API predeterminada para un usuario, pero para los dem√°s, usaremos su objeto API como par√°metro. En el siguiente ejemplo, creamos dos AdUsers: el primero con la API predeterminada y el segundo con su objeto API:

FacebookAdsApi.set_default_api ( api1 )‚Äã‚Äã

me1  =  Usuario de anuncio ( fbid = 'yo' ) 
me2  =  Usuario de anuncio ( fbid = 'yo' ,  api = api2 )
Otra forma de crear los mismos objetos anteriores ser√≠a:

me1  =  AdUser ( fbid = 'yo' ,  api = api1 ) 
me2  =  AdUser ( fbid = 'yo' ,  api = api2 )
A partir de aqu√≠, el flujo de trabajo para estos objetos se mantiene igual. Las √∫nicas excepciones son las llamadas a m√©todos de clase, donde ahora debemos pasar la API que queremos usar como √∫ltimo par√°metro en cada llamada. Por ejemplo, una llamada al m√©todo Aduser.get_by_ids deber√≠a ser as√≠:

sesi√≥n  =  FacebookSession ( 
 mi_id_de_aplicaci√≥n , 
 mi_secreto_de_aplicaci√≥n , 
 mi_token_de_acceso_1 , 
 proxies , 
)

api  =  FacebookAdsApi ( sesi√≥n1 ) 
Aduser.get_by_ids ( ids = [ ' <UID_1> ' , '<UID_2>' ], api = api )  
CRUD
Todas las llamadas CRUD admiten un paramsargumento de palabra clave que toma un diccionario que asigna los nombres de los par√°metros a sus valores en caso de que se requiera una modificaci√≥n avanzada. Puede encontrar la lista de nombres de par√°metros como atributos de [nombre de la {your object class}.Fieldclase]. Dentro de la clase Campo puede haber otras clases que contengan, como atributos, campos v√°lidos del valor de una de las propiedades principales.

api_updatey create_xxxadmite un filesargumento de palabra clave que toma un diccionario que asigna nombres de referencia de archivo a objetos de archivo binarios abiertos.

api_getAdmite un fieldsargumento de palabra clave, lo cual es una forma conveniente de especificar el par√°metro 'campos'. fieldsToma una lista de campos que deben leerse durante la llamada. Los campos v√°lidos se encuentran como atributos de la clase Campo.

Bordes
Al inicializar un EdgeIteratoro al llamar a un m√©todo como por ejemplo AdAccount.get_ad_campaigns:

Puede especificar un fieldsargumento que tome una lista de campos para leer para los objetos que se est√°n leyendo.
Puede especificar un paramsargumento que pueda ayudarle a especificar o filtrar el borde con mayor precisi√≥n.
Llamadas por lotes
Es eficiente agrupar un gran n√∫mero de llamadas en una sola solicitud HTTP. El SDK simplifica este proceso. Puedes agrupar las llamadas en una instancia de FacebookAdsApiBatch[disponible en facebook_business.api]. Para obtener f√°cilmente una para tu instancia de API:

mi_api_batch  =  api . nuevo_batch ()
Las llamadas se pueden agregar al lote en lugar de ejecutarse inmediatamente:

campa√±a .api_delete ( batch = my_api_batch )‚Äã
Una vez que haya terminado de agregar llamadas al lote, puede enviar la solicitud:

my_api_batch .execute ( )
Siga las directrices de llamadas por lotes de la documentaci√≥n de la API de Marketing . Hay un n√∫mero √≥ptimo de llamadas por lote. Adem√°s, tenga en cuenta la limitaci√≥n de velocidad, ya que una llamada por lotes simplemente mejora el rendimiento de la red y cada llamada cuenta individualmente para la limitaci√≥n de velocidad.

Excepciones
Consulte facebook_business.exceptionsla lista de excepciones que puede generar el SDK.

Pruebas
Pruebas unitarias
Las pruebas unitarias no requieren un token de acceso ni acceso a la red. Ejec√∫telas con su versi√≥n predeterminada de Python, como se indica a continuaci√≥n:

python -m facebook_business.test.unit
Tambi√©n puedes usar tox para ejecutar las pruebas unitarias con m√∫ltiples versiones de Python:

sudo apt-get install python-tox  # Debian/Ubuntu
sudo yum install python-tox      # Fedora
tox --skip-missing-interpreters
Puedes aumentar la cobertura del int√©rprete instalando versiones adicionales de Python. En Ubuntu, puedes usar el PPA de deadsnakes . En otras distribuciones, puedes compilar desde el c√≥digo fuente y luego usarlo sudo make altinstallpara evitar conflictos con la versi√≥n instalada en tu sistema.

Ejemplos
Los ejemplos de uso se encuentran en la examples/carpeta.

Depurar
Si este SDK no funciona como se espera, puede ser un problema del SDK o de la API.

Esto se puede identificar construyendo una solicitud cURL sin procesar y viendo si la respuesta es la esperada.

Por ejemplo:

desde facebook_business.adobjects.page importar P√°gina desde facebook_business.api importar FacebookAdsApi   
   

FacebookAdsApi .init ( access_token = access_token , debug = True ) page = Page ( page_id ) .api_get ( fields = campos , params = par√°metros )‚Äã‚Äã 
  
Al ejecutar este c√≥digo, esta solicitud cURL se imprimir√° en la consola como:

curl -X 'GET' -H 'Accept: */*' -H 'Accept-Encoding: gzip, deflate' -H 'Connection: keep-alive' -H 'User-Agent: fbbizsdk-python-v3.3.1' 'https://graph.facebook.com/v3.3/<pageid>/?access_token=<access_token>&fields=name%2Cbirthday%2Cphone'
Generaci√≥n de c√≥digo SDK
Nuestro SDK se genera autom√°ticamente a partir de SDK Codegen . Si desea obtener m√°s informaci√≥n sobre c√≥mo se genera el c√≥digo de nuestro SDK, consulte este repositorio.

Asunto
Como queremos gestionar los errores de forma m√°s eficiente, hemos decidido cerrar el sistema de informes de errores en Github y pasar a nuestro canal dedicado. Si encuentra un error con Business SDK (Python), inf√≥rmelo en nuestro canal de informes de errores para desarrolladores .

Licencia
El SDK empresarial de Facebook para Python tiene licencia bajo el archivo LICENSE en el directorio ra√≠z de este √°rbol de origen.


Solicitudes por lotes
Env√≠a una solicitud HTTP que contenga varias llamadas a la API Graph de Facebook. Las operaciones independientes se procesan en paralelo mientras tus operaciones dependientes se procesan consecutivamente. Una vez que todas las operaciones est√°n completas, se te devuelve una respuesta consolidada y se cierra la conexi√≥n HTTP.

El orden de las respuestas se corresponde con el orden de las operaciones en la solicitud. Por ese motivo, deber√≠as procesar las respuestas para determinar qu√© operaciones resultaron satisfactorias y cu√°les deber√≠an intentarse en las operaciones posteriores.

Limitaciones
Las solicitudes por lotes se limitan a 50 solicitudes por lote. Cada llamada dentro del lote se cuenta por separado con el fin de calcular los l√≠mites de recursos y de llamadas a la API. Por ejemplo, un lote de diez llamadas a la API contar√° como diez llamadas y cada llamada dentro del lote contribuir√° a los l√≠mites de recursos de CPU de la misma manera. Consulta nuestra Gu√≠a de limitaci√≥n de frecuencia para obtener m√°s informaci√≥n.
Las solicitudes por lote no pueden incluir varios conjuntos de anuncios en la misma campa√±a. Obt√©n m√°s informaci√≥n sobre el procesamiento por lotes de las solicitudes de la API de marketing.
Solicitudes por lotes
Una solicitud por lotes presenta un objeto JSON que consiste en una matriz de tus solicitudes. Devuelve una matriz de respuestas HTTP l√≥gicas representadas como matrices JSON. Cada respuesta tiene un c√≥digo de estado, una matriz de encabezados opcional y un cuerpo opcional (que es una cadena con codificaci√≥n JSON).

Para realizar una solicitud por lotes, env√≠a una solicitud POST a un punto de conexi√≥n punto de conexi√≥n en el que el par√°metro batch sea tu objeto JSON.

POST /ENDPOINT?batch=[JSON-OBJECT]
Ejemplo de solicitud por lotes

En este ejemplo, obtenemos informaci√≥n de dos p√°ginas que nuestra app administra.

El formato se modific√≥ para facilitar la lectura.
curl -i -X POST 'https://graph.facebook.com/me?batch=  
  [
    {
      "method":"GET",
      "relative_url":"PAGE-A-ID"
    },  
    {
      "method":"GET",
      "relative_url":"PAGE-B-ID"
    }
  ]
  &include_headers=false             // Included to remove header information
  &access_token=ACCESS-TOKEN'
Una vez que todas las operaciones est√©n completas, se env√≠a una respuesta con el resultado de cada operaci√≥n. Dado que los encabezados devueltos a veces pueden ser m√°s grandes que la respuesta de la API real, tal vez prefieras eliminarlos a fin de mejorar la eficacia. Para incluir informaci√≥n de encabezado, elimina el par√°metro include_headers o config√∫ralo como true.

Ejemplo de respuesta

El campo del cuerpo contiene un objeto JSON de cadena codificada:

[
  {
    "code": 200,
    "body": "{
      \"name\": \"Page A Name\",
      \"id\": \"PAGE-A-ID\"
      }"
  },
  {
    "code": 200,
    "body": "{
      \"name\": \"Page B Name\",
      \"id\": \"PAGE-B-ID\"
      }"
  }
]
Solicitudes por lotes complejas
Es posible combinar operaciones que normalmente utilizar√≠an distintos m√©todos HTTP en una sola solicitud por lotes. Mientras que las operaciones GET y DELETE solo pueden tener una direcci√≥n relative_url y un campo method, las operaciones POST y PUT pueden tener un campo body opcional. El cuerpo debe tener el formato de una cadena POST HTTP sin procesar, similar a una cadena de consulta URL.

Ejemplo de solicitud

En el siguiente ejemplo, se muestra una publicaci√≥n en una p√°gina que administramos y en la que tenemos permisos de publicaci√≥n, y despu√©s las noticias de la p√°gina en una sola operaci√≥n:

curl "https://graph.facebook.com/PAGE-ID?batch=
  [
    { 
      "method":"POST",
      "relative_url":"PAGE-ID/feed",
      "body":"message=Test status update"
    },
    { 
      "method":"GET",
      "relative_url":"PAGE-ID/feed"
    }
  ]
  &access_token=ACCESS-TOKEN"
El resultado de esta llamada es:

[
    { "code": 200,
      "headers": [
          { "name":"Content-Type", 
            "value":"text/javascript; charset=UTF-8"}
       ],
      "body":"{\"id\":\"‚Ä¶\"}"
    },
    { "code": 200,
      "headers": [
          { "name":"Content-Type", 
            "value":"text/javascript; charset=UTF-8"
          },
          { "name":"ETag", 
            "value": "‚Ä¶"
          }
      ],
      "body": "{\"data\": [{‚Ä¶}]}
    }
]
En el siguiente ejemplo, se crea un nuevo anuncio para una campa√±a y despu√©s se obtienen detalles del objeto reci√©n creado. Ten en cuenta la operaci√≥n URLEncoding para el par√°metro del cuerpo:

curl \
-F 'access_token=...' \
-F 'batch=[
  {
    "method":"POST",
    "name":"create-ad",
    "relative_url":"11077200629332/ads",
    "body":"ads=%5B%7B%22name%22%3A%22test_ad%22%2C%22billing_entity_id%22%3A111200774273%7D%5D"
  }, 
  {
    "method":"GET",
    "relative_url":"?ids={result=create-ad:$.data.*.id}"
  }
]' \
https://graph.facebook.com
En el siguiente ejemplo, se agregan varias p√°ginas a un administrador comercial:

curl \
-F 'access_token=<ACCESS_TOKEN>' \
-F 'batch=[
  {
    "method":"POST",
    "name":"test1",
    "relative_url":"<BUSINESS_ID>/owned_pages",
    "body":"page_id=<PAGE_ID_1>"
  }, 
  {
    "method":"POST",
    "name":"test2",
    "relative_url":"<BUSINESS_ID>/owned_pages",
    "body":"page_id=<PAGE_ID_2>"
  }, 
  {
    "method":"POST",
    "name":"test3",
    "relative_url":"<BUSINESS_ID>/owned_pages",
    "body":"page_id=<PAGE_ID_3>"
  }, 
]' \
"https://graph.facebook.com/v12.0"
D√≥nde:

<ACCESS_TOKEN> es un token de acceso con el permiso business_management.
<BUSINESS_ID> es el identificador del administrador comercial al cual deben solicitarse las p√°ginas.
<PAGE_ID_n> son los identificadores de la p√°gina que se debe solicitar.
Errores
Es posible que una de tus operaciones solicitadas genere un error. Esto podr√≠a deberse a que, por ejemplo, no tienes permiso para realizar la operaci√≥n solicitada. La respuesta es similar a la API Graph est√°ndar, pero encapsulada en la sintaxis de respuesta por lotes:

[
    { "code": 403,
      "headers": [
          {"name":"WWW-Authenticate", "value":"OAuth‚Ä¶"},
          {"name":"Content-Type", "value":"text/javascript; charset=UTF-8"} ],
      "body": "{\"error\":{\"type\":\"OAuthException\", ‚Ä¶ }}"
    }
]
Las restantes solicitudes del lote deber√≠an seguir correctamente de todas formas y se devolver√°n, como siempre, con un c√≥digo de estado 200.

Tiempos de espera
El tiempo de espera de los lotes grandes o complejos se puede agotar si todas las solicitudes dentro del lote tardan mucho en completarse. En tal circunstancia, el resultado es un lote parcialmente completado. En un lote parcialmente completado, las solicitudes que se completan de forma satisfactoria devolver√°n el resultado normal con el c√≥digo de estado 200. Las respuestas a las solicitudes que no sean satisfactorias ser√°n null. Puedes volver a intentar realizar cualquier solicitud que no haya sido satisfactoria.

Llamadas por lotes con JSONP
La API por lotes admite JSONP, al igual que el resto de la API Graph (la funci√≥n de devoluci√≥n de llamada de JSONP se especifica con el par√°metro de publicaci√≥n de formulario o cadena de consulta callback).

Uso de varios tokens de acceso
Las solicitudes individuales de una misma solicitud por lotes pueden especificar sus propios tokens de acceso como cadena de consulta o formar par√°metros de publicaci√≥n. En ese caso, el token de acceso de nivel superior se considera un token de reserva y se utiliza si una solicitud individual no especific√≥ expl√≠citamente un token de acceso.

Esto puede resultar √∫til cuando quieres consultar la API con distintos tokens de acceso de usuario o tokens de acceso a la p√°gina, o si es necesario realizar algunas de las llamadas con un token de acceso de app.

Debes incluir un token de acceso como par√°metro de nivel superior, aun cuando todas las solicitudes individuales contengan sus propios tokens.

Subir datos binarios
Puedes subir varios elementos binarios como parte de una llamada por lotes. Para ello, necesitas agregar todos los elementos binarios como archivos adjuntos MIME o de varias partes a tu solicitud y necesitas que cada operaci√≥n haga referencia a sus elementos binarios con la propiedad attached_files en la operaci√≥n. La propiedad attached_files admite una lista separada por comas de nombres de archivos adjuntos en su valor.

En el siguiente ejemplo, se muestra c√≥mo subir dos fotos en una sola llamada por lotes:

curl 
     -F 'access_token=‚Ä¶' \
     -F 'batch=[{"method":"POST","relative_url":"me/photos","body":"message=My cat photo","attached_files":"file1"},{"method":"POST","relative_url":"me/photos","body":"message=My dog photo","attached_files":"file2"},]' \
     -F 'file1=@cat.gif' \
     -F 'file2=@dog.jpg' \
    https://graph.facebook.com

## Obtener Conversaciones de Mensajer√≠a (Messaging Conversations)

### Introducci√≥n a las M√©tricas de Conversaciones

Las conversaciones iniciadas por mensajer√≠a son una m√©trica crucial para anuncios que tienen como objetivo generar leads a trav√©s de plataformas de mensajer√≠a como WhatsApp, Instagram Direct o Facebook Messenger. Estas m√©tricas son especialmente importantes para campa√±as Click-to-Message.

### Tipos de Acciones de Mensajer√≠a Disponibles

La API de Facebook devuelve varios tipos de acciones relacionadas con mensajer√≠a:

- `onsite_conversion.messaging_conversation_started_7d` - Conversaciones iniciadas en ventana de 7 d√≠as
- `onsite_conversion.messaging_first_reply` - Primeras respuestas del usuario
- `onsite_conversion.total_messaging_connection` - Total de conexiones de mensajer√≠a
- `onsite_conversion.messaging_user_depth_2_message_send` - Usuarios que enviaron 2+ mensajes
- `onsite_conversion.messaging_user_depth_3_message_send` - Usuarios que enviaron 3+ mensajes
- `onsite_conversion.messaging_welcome_message_view` - Visualizaciones del mensaje de bienvenida
- `onsite_conversion.messaging_conversation_replied_7d` - Conversaciones respondidas en 7 d√≠as

### M√©todo 1: Usando Graph API Directamente

```python
import requests
import json
from datetime import datetime, date, timedelta

def obtener_conversaciones_graph_api(ad_account_id, access_token, fecha_inicio, fecha_fin):
    url = f"https://graph.facebook.com/v19.0/act_{ad_account_id}/insights"
    
    params = {
        'access_token': access_token,
        'level': 'ad',
        'fields': 'ad_id,ad_name,actions,spend,impressions',
        'action_attribution_windows': ['7d_click', '1d_view'],
        'time_range': json.dumps({
            'since': fecha_inicio.strftime('%Y-%m-%d'),
            'until': fecha_fin.strftime('%Y-%m-%d')
        }),
        'limit': 500
    }
    
    response = requests.get(url, params=params)
    data = response.json()
    insights = data.get('data', [])
    
    for insight in insights:
        actions = insight.get('actions', [])
        for action in actions:
            action_type = action.get('action_type')
            value = action.get('value')
            
            # Buscar conversaciones de mensajer√≠a
            if 'messaging_conversation_started' in action_type:
                print(f"Conversaciones: {action_type} = {value}")
```

### M√©todo 2: Usando Facebook Business SDK (Recomendado)

```python
from facebook_business.api import FacebookAdsApi
from facebook_business.adobjects.adaccount import AdAccount
from facebook_business.adobjects.ad import Ad

# Inicializar API
FacebookAdsApi.init(app_id, app_secret, access_token)

def obtener_conversaciones_sdk(ad_account_id, fecha_inicio, fecha_fin):
    account = AdAccount(f'act_{ad_account_id}')
    
    # Obtener anuncios
    ads = account.get_ads(fields=['id', 'name', 'status'])
    
    for ad in ads:
        # Obtener insights del anuncio
        insights = ad.get_insights(
            fields=[
                'ad_id',
                'ad_name',
                'actions',
                'spend',
                'impressions'
            ],
            params={
                'time_range': {
                    'since': fecha_inicio.strftime('%Y-%m-%d'),
                    'until': fecha_fin.strftime('%Y-%m-%d')
                },
                'action_attribution_windows': ['7d_click', '1d_view']
            }
        )
        
        for insight in insights:
            actions = insight.get('actions', [])
            
            for action in actions:
                action_type = action.get('action_type', '')
                value = action.get('value', 0)
                
                # Filtrar acciones de mensajer√≠a
                if any(keyword in action_type.lower() for keyword in ['messaging', 'conversation']):
                    print(f"üí¨ {action_type}: {value}")
```

### M√©todo 3: Insights Espec√≠ficos por Anuncio

```python
from facebook_business.adobjects.ad import Ad

def obtener_conversaciones_por_anuncio(ad_id, fecha_inicio, fecha_fin):
    ad = Ad(ad_id)
    
    insights = ad.get_insights(
        fields=['messages', 'conversations_started', 'actions'],
        params={
            'time_range': {
                'since': fecha_inicio.strftime('%Y-%m-%d'),
                'until': fecha_fin.strftime('%Y-%m-%d')
            }
        }
    )
    
    for insight in insights:
        # M√©tricas directas (si est√°n disponibles)
        messages = insight.get('messages', 0)
        conversations = insight.get('conversations_started', 0)
        
        print(f"Mensajes: {messages}")
        print(f"Conversaciones iniciadas: {conversations}")
        
        # Acciones detalladas
        actions = insight.get('actions', [])
        for action in actions:
            if 'messaging' in action.get('action_type', '').lower():
                print(f"{action.get('action_type')}: {action.get('value')}")
```

### Requisitos para Obtener M√©tricas de Conversaciones

1. **Objetivo de Campa√±a**: Los anuncios deben tener objetivo de "Mensajes" o "Generaci√≥n de clientes potenciales"
2. **Tipo de Anuncio**: Click-to-Message, Click-to-WhatsApp, o Click-to-Messenger
3. **Configuraci√≥n**: Los anuncios deben estar configurados espec√≠ficamente para iniciar conversaciones
4. **Permisos**: El token de acceso debe tener permisos `ads_management`
5. **Ventana de Atribuci√≥n**: Usar ventanas de 7 d√≠as para capturar conversaciones completas

### Ejemplo Completo de Implementaci√≥n

```python
import os
from datetime import datetime, date, timedelta
from facebook_business.api import FacebookAdsApi
from facebook_business.adobjects.adaccount import AdAccount

def sincronizar_conversaciones_meta_ads():
    # Configuraci√≥n
    access_token = os.getenv('META_ACCESS_TOKEN')
    app_id = os.getenv('META_APP_ID', 'dummy_app_id')
    app_secret = os.getenv('META_APP_SECRET', 'dummy_secret')
    
    FacebookAdsApi.init(app_id, app_secret, access_token)
    
    # Fechas
    fecha_fin = date.today() - timedelta(days=1)
    fecha_inicio = fecha_fin - timedelta(days=7)
    
    # Cuenta publicitaria
    account = AdAccount('act_YOUR_ACCOUNT_ID')
    
    # Obtener insights con conversaciones
    insights = account.get_insights(
        fields=['actions', 'spend', 'impressions'],
        params={
            'time_range': {
                'since': fecha_inicio.strftime('%Y-%m-%d'),
                'until': fecha_fin.strftime('%Y-%m-%d')
            },
            'level': 'ad',
            'action_attribution_windows': ['7d_click', '1d_view']
        }
    )
    
    total_conversaciones = 0
    
    for insight in insights:
        actions = insight.get('actions', [])
        
        for action in actions:
            action_type = action.get('action_type', '')
            value = int(action.get('value', 0))
            
            # Capturar todas las m√©tricas de conversaciones
            if action_type in [
                'onsite_conversion.messaging_conversation_started_7d',
                'onsite_conversion.messaging_first_reply',
                'onsite_conversion.total_messaging_connection'
            ]:
                total_conversaciones += value
                print(f"‚úÖ {action_type}: {value}")
    
    print(f"Total conversaciones encontradas: {total_conversaciones}")
    
    return total_conversaciones

# Ejecutar sincronizaci√≥n
if __name__ == "__main__":
    conversaciones = sincronizar_conversaciones_meta_ads()
```

### Notas Importantes

- **Formato de Respuesta**: Las acciones de mensajer√≠a vienen con prefijo `onsite_conversion.`
- **Ventanas de Atribuci√≥n**: Usar `7d_click` y `1d_view` para m√°xima cobertura
- **Filtrado**: No todos los anuncios generar√°n conversaciones de mensajer√≠a
- **Debugging**: Siempre imprimir todas las acciones disponibles para verificar estructura
- **Rendimiento**: Usar llamadas por lotes para cuentas con muchos anuncios